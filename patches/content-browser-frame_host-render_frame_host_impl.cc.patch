diff --git a/content/browser/frame_host/render_frame_host_impl.cc b/content/browser/frame_host/render_frame_host_impl.cc
index 1531d69cfe3d6c975073d293edf15e0bc4d9325b..a9d92944c7a3dc8e5d38f8136d8a38ed38d91539 100644
--- a/content/browser/frame_host/render_frame_host_impl.cc
+++ b/content/browser/frame_host/render_frame_host_impl.cc
@@ -3496,8 +3496,19 @@ void RenderFrameHostImpl::ReportHeavyAdIssue(
 }
 
 StoragePartition* RenderFrameHostImpl::GetStoragePartition() {
-  return BrowserContext::GetStoragePartition(GetBrowserContext(),
-                                             GetSiteInstance());
+  bool should_use_ephemeral_storage =
+      !frame_tree_node_->IsMainFrame() && ComputeSiteForCookies().IsNull();
+  if (!should_use_ephemeral_storage) {
+    return BrowserContext::GetStoragePartition(GetBrowserContext(),
+                                               GetSiteInstance());
+  } else {
+      std::string domain = std::string("ephemeral-") +
+          base::NumberToString(GetRenderViewHost()->GetRoutingID());
+      std::string name;
+      StoragePartitionConfig config =
+          StoragePartitionConfig::Create(domain, name, true /* in_memory */);
+    return BrowserContext::GetStoragePartition(GetBrowserContext(), config);
+  }
 }
 
 void RenderFrameHostImpl::RequestTextSurroundingSelection(
@@ -6115,8 +6126,7 @@ void RenderFrameHostImpl::CommitNavigation(
     }
 #endif
 
-    StoragePartition* partition =
-        BrowserContext::GetStoragePartition(browser_context, GetSiteInstance());
+    StoragePartition* partition = GetStoragePartition();
     auto storage_partition_config =
         GetContentClient()->browser()->GetStoragePartitionConfigForSite(
             browser_context, site_instance_->GetSiteInfo().site_url());
@@ -6225,9 +6235,8 @@ void RenderFrameHostImpl::CommitNavigation(
       // factories. TODO(kinuko): Consider setting this up only when prefetch
       // is used. Currently we have this here to make sure we have non-racy
       // situation (https://crbug.com/849929).
-      auto* storage_partition = static_cast<StoragePartitionImpl*>(
-          BrowserContext::GetStoragePartition(
-              GetSiteInstance()->GetBrowserContext(), GetSiteInstance()));
+      auto* storage_partition =
+          static_cast<StoragePartitionImpl*>(GetStoragePartition());
       storage_partition->GetPrefetchURLLoaderService()->GetFactory(
           prefetch_loader_factory.InitWithNewPipeAndPassReceiver(),
           frame_tree_node_->frame_tree_node_id(),
@@ -6481,8 +6490,7 @@ void RenderFrameHostImpl::SetUpMojoIfNeeded() {
       base::Unretained(this)));
 
   file_system_manager_.reset(new FileSystemManagerImpl(
-      GetProcess()->GetID(),
-      GetProcess()->GetStoragePartition()->GetFileSystemContext(),
+      GetProcess()->GetID(), GetStoragePartition()->GetFileSystemContext(),
       ChromeBlobStorageContext::GetFor(GetProcess()->GetBrowserContext())));
 
   mojo::PendingRemote<mojom::FrameFactory> frame_factory;
@@ -6949,8 +6957,7 @@ bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryAndObserve(
       (!network_service_disconnect_handler_holder_ ||
        !network_service_disconnect_handler_holder_.is_connected())) {
     network_service_disconnect_handler_holder_.reset();
-    StoragePartition* storage_partition = BrowserContext::GetStoragePartition(
-        GetSiteInstance()->GetBrowserContext(), GetSiteInstance());
+    StoragePartition* storage_partition = GetStoragePartition();
     network::mojom::URLLoaderFactoryParamsPtr monitoring_factory_params =
         network::mojom::URLLoaderFactoryParams::New();
     monitoring_factory_params->process_id = GetProcess()->GetID();
@@ -6994,8 +7001,11 @@ bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryInternal(
       this, false /* is_navigation */, false /* is_download */,
       &default_factory_receiver, &params->factory_override);
 
-  GetProcess()->CreateURLLoaderFactory(std::move(default_factory_receiver),
-                                       std::move(params));
+  RenderProcessHostImpl* process =
+      static_cast<RenderProcessHostImpl*>(GetProcess());
+  process->CreateURLLoaderFactory(GetStoragePartition(),
+                                  std::move(default_factory_receiver),
+                                  std::move(params));
 
   return bypass_redirect_checks;
 }
@@ -7423,7 +7433,7 @@ void RenderFrameHostImpl::GetIdleManager(
     mojo::ReportBadMessage("Feature policy blocks access to IdleDetection.");
     return;
   }
-  static_cast<StoragePartitionImpl*>(GetProcess()->GetStoragePartition())
+  static_cast<StoragePartitionImpl*>(GetStoragePartition())
       ->GetIdleManager()
       ->CreateService(std::move(receiver),
                       GetMainFrame()->GetLastCommittedOrigin());
@@ -7502,7 +7512,7 @@ void RenderFrameHostImpl::BindSmsReceiverReceiver(
 
 void RenderFrameHostImpl::BindRestrictedCookieManager(
     mojo::PendingReceiver<network::mojom::RestrictedCookieManager> receiver) {
-  static_cast<StoragePartitionImpl*>(GetProcess()->GetStoragePartition())
+  static_cast<StoragePartitionImpl*>(GetStoragePartition())
       ->CreateRestrictedCookieManager(
           network::mojom::RestrictedCookieManagerRole::SCRIPT,
           GetLastCommittedOrigin(), isolation_info_.site_for_cookies(),
@@ -7598,6 +7608,23 @@ void RenderFrameHostImpl::GetFileSystemManager(
                                 std::move(receiver)));
 }
 
+void RenderFrameHostImpl::BindDomStorage(
+    mojo::PendingReceiver<blink::mojom::DomStorage> receiver,
+    mojo::PendingRemote<blink::mojom::DomStorageClient> client) {
+  static_cast<StoragePartitionImpl*>(GetStoragePartition())
+      ->BindDomStorage(GetProcess()->GetID(), std::move(receiver),
+                       std::move(client));
+
+  // Renderers only use this interface to send a single BindDomStorage message,
+  // so we can tear down the receiver now.
+  dom_storage_provider_receiver_.reset();
+}
+void RenderFrameHostImpl::GetDomStorageProvider(
+    mojo::PendingReceiver<blink::mojom::DomStorageProvider> receiver) {
+  DCHECK(!dom_storage_provider_receiver_.is_bound());
+  dom_storage_provider_receiver_.Bind(std::move(receiver));
+}
+
 void RenderFrameHostImpl::GetGeolocationService(
     mojo::PendingReceiver<blink::mojom::GeolocationService> receiver) {
   if (!geolocation_service_) {
@@ -7614,7 +7641,7 @@ void RenderFrameHostImpl::GetNativeFileSystemManager(
     mojo::PendingReceiver<blink::mojom::NativeFileSystemManager> receiver) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   auto* storage_partition =
-      static_cast<StoragePartitionImpl*>(GetProcess()->GetStoragePartition());
+      static_cast<StoragePartitionImpl*>(GetStoragePartition());
   auto* manager = storage_partition->GetNativeFileSystemManager();
   manager->BindReceiver(NativeFileSystemManagerImpl::BindingContext(
                             GetLastCommittedOrigin(), GetLastCommittedURL(),
@@ -7630,7 +7657,16 @@ void RenderFrameHostImpl::CreateLockManager(
 
 void RenderFrameHostImpl::CreateIDBFactory(
     mojo::PendingReceiver<blink::mojom::IDBFactory> receiver) {
-  GetProcess()->BindIndexedDB(GetLastCommittedOrigin(), std::move(receiver));
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (GetLastCommittedOrigin().opaque()) {
+    // Opaque origins aren't valid for IndexedDB access, so we won't bind
+    // |receiver| to |indexed_db_factory_|.  Return early here which
+    // will cause |receiver| to be freed.  When |receiver| is
+    // freed, we expect the pipe on the client will be closed.
+    return;
+  }
+  GetStoragePartition()->GetIndexedDBControl().BindIndexedDB(
+      GetLastCommittedOrigin(), std::move(receiver));
 }
 
 void RenderFrameHostImpl::CreatePermissionService(
@@ -7655,10 +7691,11 @@ void RenderFrameHostImpl::GetAuthenticator(
 void RenderFrameHostImpl::GetPushMessaging(
     mojo::PendingReceiver<blink::mojom::PushMessaging> receiver) {
   if (!push_messaging_manager_) {
-    push_messaging_manager_.reset(new PushMessagingManager(
-        GetProcess()->GetID(), routing_id_,
-        static_cast<StoragePartitionImpl*>(GetProcess()->GetStoragePartition())
-            ->GetServiceWorkerContext()));
+    auto* storage_partition =
+        static_cast<StoragePartitionImpl*>(GetStoragePartition());
+    push_messaging_manager_.reset(
+        new PushMessagingManager(GetProcess()->GetID(), routing_id_,
+                                 storage_partition->GetServiceWorkerContext()));
   }
 
   RunOrPostTaskOnThread(
